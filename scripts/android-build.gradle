apply plugin: 'com.android.library'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-kapt'
apply plugin: 'kotlin-parcelize'

def static isNotNull(Object value) {
    if (!(value == null || value.isEmpty())) {
        return true
    } else {
        return false
    }
}

android {
    namespace 'aosp.' + project.getName()
    def androidSdk = rootProject.ext.androidSdk
    compileSdkVersion androidSdk.compileSdkVersion
    buildToolsVersion androidSdk.buildToolsVersion
    defaultConfig {
        minSdkVersion androidSdk.minSdkVersion
        targetSdkVersion androidSdk.targetSdkVersion

        if (isNotNull(BUILD_NATIVE_ROOT)) {
            println(project.getName() + " config c/cpp code, root dir = " + BUILD_NATIVE_ROOT)
            externalNativeBuild {
                cmake {
                    cppFlags "-std=c++20"
                    abiFilters "arm64-v8a"
                    arguments "-DBUILD_NATIVE_ROOT=" + BUILD_NATIVE_ROOT
                }
            }
        }
    }

    sourceSets {
        main {
            if (isNotNull(BUILD_MANIFEST)) {
                manifest.srcFile BUILD_MANIFEST
            }

            if (isNotNull(BUILD_ASSETS)) {
                assets.srcDirs = [BUILD_ASSETS]
            }

            if (isNotNull(BUILD_RES)) {
                res.srcDirs = [BUILD_RES]
            }

            if (isNotNull(BUILD_SRC)) {
                java.srcDirs = [BUILD_SRC]
            }

            if (rootProject.ext.build_aidl.toBoolean() && isNotNull(BUILD_AIDL)) {
                aidl.srcDirs = [BUILD_AIDL]
            }
        }
    }

    if (isNotNull(BUILD_NATIVE_ROOT)) {
        externalNativeBuild {
            cmake {
                path "CMakeLists.txt"
            }
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    buildFeatures {
        //这里不加 build_aidl 熟悉判断的原因是:
        //如果加了判断，改 false 后，as就不会把生成的java当做源文件对待
        aidl = true
    }
}

task deleteAndroidSdk {
    def dir = "${rootDir}" + File.separator + ".idea" + File.separator + "modules" + File.separator + project.name + File.separator

    // 新版本的 idea 生成的目录不再是 project.name [个人觉得是idea的bug], 所以只能从 modules 文件夹开始遍历。
    // TODO 后续可能会优化
    // 新版本的 as 甚至都不会生成 [project.name].main.iml
    def folder = new File(dir)
    if (!folder.exists()) {
        dir = "${rootDir}" + File.separator + ".idea" + File.separator + "modules"
    }

    def files = fileTree(dir).filter { it.isFile() }.files.absoluteFile
    files.forEach { file ->
        def imlFile = file
        def fileName = file.name
        def projectDir = file.path
        def projectFile = rootProject.name + "." + project.name + ".main.iml"
        if (fileName.contains(projectFile)) {
            def scriptFile = "${rootDir}" + File.separator + "scripts" + File.separator + "delete-sdk.py"
            def cmd = "python " + scriptFile + " -d " + projectDir
            println(cmd)
            def script = cmd.execute()
            script.waitFor()

            try {
                def parsedXml = (new XmlParser()).parse(imlFile)
                def jdkNode = parsedXml.component[1].orderEntry.find { it.'@type' == 'jdk' }
                def jdkName = jdkNode.attributes().get('jdkName')
                parsedXml.component[1].remove(jdkNode)
                new groovy.util.Node(parsedXml.component[1], 'orderEntry', ['type': 'jdk', 'jdkName': jdkName, 'jdkType': 'Android SDK'])
                groovy.xml.XmlUtil.serialize(parsedXml, new FileOutputStream(imlFile))
            } catch (Exception e) {
                println("sort sdk node error, " + e)
            }
        }
    }
}

task excludeFolder {
    if (isNotNull(BUILD_NATIVE_ROOT)) {
        def dir = "${rootDir}" + File.separator + ".idea" + File.separator + "modules" + File.separator + project.name + File.separator
        def files = fileTree(dir).filter { it.isFile() }.files.name
        files.forEach { file ->
            if (file.contains("main.iml")) {
                def imlFile = dir + file
                def scriptFile = "${rootDir}" + File.separator + "scripts" + File.separator + "exclude-folder.py"
                println(scriptFile)
                def cmd = "python " + scriptFile + " -p " + rootProject.name + " -f " + imlFile
                println(cmd)
                def script = cmd.execute()
                script.waitFor()
            }
        }
    }
}

dependencies {
    if (isNotNull(BUILD_NATIVE_ROOT)) {
        println("Native [" + project.getName() + "] don't dependence other project")
    } else {
        rootProject.ext.allModules.each { dependence ->
            if (dependence.key == project.name) {
                println("Don't compileOnly myself, project = " + project.name)
            } else {
                if (rootProject.ext.build_aidl.toBoolean()) {
                    println("don't compileOnly forEach when build aidl")
                } else {
                    compileOnly project(dependence.value)
                }
            }
        }
    }
}
